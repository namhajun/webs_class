<!DOCTYPE html>
<html lang="en">

<head>

    <title>Document</title>
</head>

<body>
    <div class="iframe">
        <iframe src="https://namhajun.github.io/webs_class/javascript/effect/searchEffect01.html"></iframe>
    </div>
    <pre class="typescript"><code>
        const searchBox = document.querySelector("#search-box");    //search-box 변수에 저장
        const cssList = document.querySelectorAll(".list ul li");   //다수의 li를 변수에 저장
        const cssCount = document.querySelector(".count em");
        
        cssList.forEach((element, index) => {
            element.classList.add("show");
            cssCount.innerHTML = index + 1;
            });
        
        searchBox.addEventListener("keyup", () => {     //input를 클릭했을 때 이벤트 설정
            const searchWord = searchBox.value;    //사용자가 입력한 데이터 저장소 변수에 저장
        
            cssList.forEach(el => {                 //다수의 li한테 적용
                console.log(el.dataset.name)
        
                const cssName = el.dataset.name;    //CSS 속성 값을 변수에 저장
        
                if(cssName.indexOf(searchWord)){     //사용자가 입력한 값이 데이터가 있는지 확인
                    el.classList.add("hide");       //데이터가 있으면 클래스 add를 추가
                } else {
                       el.classList.remove("hide");    //데이터가 있으면 클래스 add를 삭제
                }
           });
        })

</code></pre>

    <a href="https://namhajun.github.io/webs_class/javascript/javascript06.html#sample10">indexOF()</a>


    <div class="iframe">
        <iframe src="https://namhajun.github.io/webs_class/javascript/effect/searchEffect02.html"></iframe>
    </div>
    <pre class="typescript"><code>
        const searchBox = document.querySelector("#search-box");    //search-box 변수에 저장
        const cssList = document.querySelectorAll(".list ul li");   //다수의 li를 변수에 저장
        const cssCount = document.querySelector(".count em");   //전체 li갯수를 표시
        
        cssList.forEach((element, index) => {
            element.classList.add("show");
            cssCount.innerHTML = index + 1;
            });
        
        searchBox.addEventListener("keyup", () => {     //input을 클릭했을 때 이벤트 설정
            const searchWord = searchBox.value;    //사용자가 입력한 데이터 저장소 변수에 저장
        
            // console.log(searchWord)
            
        
            cssList.forEach(el => {                 //다수의 li한테 적용
                const cssName = el.dataset.name;    //CSS 속성 값(속성 모든 값)을 변수에 저장
                // console.log(cssName)
        
                if(cssName.includes(searchWord)){   //사용자가 입력한 값의 데이터가 있는지 확인
                    el.classList.add("show");       //데이터가 있으면 클래스 add를 추가
                } else {
                    el.classList.remove("show");    //데이터가 없으면 클래스 add를 삭제
                }
            })
        })

</code></pre>

    <a href="https://namhajun.github.io/webs_class/javascript/javascript06.html#sample10">includes()</a>



    <h3>input</h3>
    <p>input 요소의 여러 속성을 사용하면 사용자가 입력하는 방식을 더욱 다양하게 제어할 수 있습니다.</p>

    <h3>value</h3>
    <p>value 속성은 input 요소의 입력 필드(input field)에 나타나는 초깃값을 설정합니다.</p>

    <h3>readonly</h3>
    <p>readonly 속성은 사용자가 입력 필드를 볼 수는 있으나, 수정할 수는 없도록 설정합니다.
        disabled 속성과 다른 점은 전송 버튼(submit)을 누르면 초깃값이 서버로 전송된다는 점입니다.</p>

    <h3>disabled </h3>
    <p>disabled 속성은 사용자가 입력 필드를 아예 사용할 수 없도록 설정합니다.

        disabled 속성이 설정된 입력 필드는 사용할 수도 없고, 클릭할 수도 없습니다.

        또한, readonly 속성과는 달리 전송 버튼(submit)을 눌러도 초깃값이 서버로 전송되지 않습니다.</p>

    <h3>maxlength </h3>
    <p>maxlength 속성은 입력 필드에 입력할 수 있는 문자의 최대 길이(length)를 설정합니다.</p>

    <h3>size </h3>
    <p>size 속성은 입력 필드에 보여지는 input 요소의 크기(size)를 설정합니다.

        maxlength 속성과는 달리 입력 필드가 한 번에 보여줄 수 있는 문자의 최대 개수만을 의미합니다.

        따라서 입력될 수 있는 문자의 최대 길이는 maxlength 속성값에 따라 달라지며, size 속성과는 전혀 무관합니다.</p>




    <h3>iframe</h3>
    <p>iframe이란 inline frame의 약자입니다.

        iframe 요소를 이용하면 해당 웹 페이지 안에 어떠한 제한 없이 또 다른 하나의 웹 페이지를 삽입할 수 있습니다.</p>

    <div class="code">
        <pre><code>
&lt;iframe src="삽입할페이지주소"&gt;&lt;/iframe&gt;
            </code></pre>
    </div>

    <p>iframe 요소는 frame 요소와는 달리 종료 태그가 존재합니다.

        또한, iframe 요소는 명시된 크기로 삽입되는 창의 크기가 고정됩니다.</p>

    <div class="code">
        <pre><code>
&lt;iframe src="/css/intro" style="width:100%; height:300px"&gt;
&lt;/iframe&gt;
            </code></pre>
    </div>
    <h3>iframe 요소의 테두리 변경</h3>
    <p>iframe 요소는 기본적으로 검정색 테두리(border)를 가집니다.

        이러한 테두리의 스타일은 style 속성에서 border 속성을 이용하면 변경할 수 있습니다.</p>
    <div class="code">
        <pre><code>
&lt;iframe src="/css/intro" style="width:100%; height:300px; border: 3px dashed maroon"&gt;
&lt;/iframe&gt;
            </code></pre>
    </div>

    <h3>iframe 요소의 페이지 변경하기</h3>
    <p>&lt;a&gt;태그를 이용하면 iframe 요소의 최초 페이지를 중간에 변경할 수 있습니다.

        &lt;a&gt;태그의 target 속성과 iframe 요소의 name 속성을 연결하면, &lt;a&gt;태그를 통해 iframe 요소의 페이지를 변경할 수 있게 됩니다.</p>
    <div class="code">
        <pre><code>
&lt;iframe src="/css/intro" name="frame_target" style="width:100%; height:400px;">&lt;/iframe&gt;
&lt;p&gt;
    &lt;a href="/php/intro" target="frame_target"&gt;PHP 수업 확인하러 가기 =&gt;&lt;/a&gt;
&lt;/p&gt;
            </code></pre>
    </div>

    <h3>프레임셋(frameset)</h3>
    <p>프레임셋(frameset)을 이용하면 하나의 브라우저 창에 둘 이상의 페이지를 표시할 수 있습니다.

        이러한 프레임셋은 iframe 요소와는 달리 하나 이상의 페이지를 동시에 가질 수 있습니다.

        또한, noresize 속성을 명시하지 않으면, 사용자가 마음대로 페이지의 크기를 조절할 수 있습니다.



        프레임셋에서 각각의 페이지는 frame 요소로 표현됩니다.

        frame 요소는 iframe 요소와는 달리 종료 태그를 가지지 않습니다.



        noframes 요소는 해당 브라우저가 frame 요소를 지원하지 않을 때 보여지는 문자열을 저장합니다.</p>


    <h3>align</h3>
    <p>블록(block) 타입의 요소를 정렬하기 위해서는 다음과 같은 방법을 사용할 수 있습니다.</p>
    <ul>
        <li>1. margin 속성을 이용한 가운데 정렬</li>

        <li> 2. position 속성을 이용한 좌우 정렬</li>

        <li> 3. float 속성을 이용한 좌우 정렬</li>
    </ul>
    <h3>margin 속성을 이용한 가운데 정렬</h3>
    <p>margin 속성값을 auto로 설정하면, 해당 요소를 감싸고 있는 컨테이너 요소를 기준으로 수평 방향 가운데 정렬이 됩니다.



        이때 해당 요소는 특정한 너비를 가져야 하며, 너비를 제외한 나머지 공간은 좌우로 균등하게 나뉘어 여백으로 만들어집니다.

        따라서 이 방법을 사용하기 위해서는 반드시 해당 요소의 width 속성값을 먼저 설정해야만 합니다.</p>
    <h3>position 속성을 이용한 좌우 정렬</h3>
    <p>절대 위치 지정 방식으로 위치한 요소는 정상적인 레이아웃에서 벗어나 다른 요소와 겹칠 수 있게 됩니다.

        따라서 이 특성을 이용하면 HTML 요소를 수평 방향으로 좌우 정렬할 수 있습니다.



        position 속성을 이용하여 정렬할 경우에는 &lt;body&gt;요소에 margin과 padding 속성값을 설정하는 것이 좋습니다.

        이렇게 함으로써 웹 브라우저마다 레이아웃이 다르게 보이는 것을 미리 방지할 수 있습니다.</p>
    <h3>float 속성을 이용한 좌우 정렬</h3>
    <p>float 속성을 이용하면 수평 방향으로 좌우 정렬할 수 있습니다.



        float 속성을 이용하여 정렬할 경우에는 &lt;body&gt;요소에 margin과 padding 속성값을 설정하는 것이 좋습니다.

        이렇게 함으로써 웹 브라우저마다 레이아웃이 다르게 보이는 것을 미리 방지할 수 있습니다.</p>

    <h3>selector</h3>
    <p>CSS에서는 스타일을 적용할 대상을 선택하기 위해서 선택자(selector)를 사용합니다.

        지금까지 살펴본 대표적인 선택자는 다음과 같습니다.</p>
    <ul>
        <li>전체 선택자</li>

        <li> HTML 요소 선택자</li>

        <li> 아이디(id) 선택자</li>

        <li> 클래스(class) 선택자</li>

        <li> 그룹(group) 선택자</li>
    </ul>

    <h3>전체 선택자</h3>
    <p>CSS를 적용할 대상으로 HTML 문서 내부의 모든 요소를 선택합니다.</p>
    <div class="code">
        <pre><code>
&lt;style&gt;
    * { color: red; }
&lt;/style&gt;
        </code></pre>
    </div>


    <h3>HTML 요소 선택자</h3>
    <p>CSS를 적용할 대상으로 HTML 요소의 이름을 직접 사용하여 선택할 수 있습니다.</p>
    <div class="code">
        <pre><code>
&lt;style&gt;
h2 { color: teal; text-decoration: underline; }
&lt;/style&gt;
        </code></pre>
    </div>


    <h3>아이디(id) 선택자</h3>
    <p>아이디 선택자는 CSS를 적용할 대상으로 특정 요소를 선택할 때 사용합니다.

        이 선택자는 웹 페이지에 포함된 여러 요소 중에서 특정 아이디 이름을 가지는 요소만을 선택해 줍니다.</p>
    <div class="code">
        <pre><code>
&lt;style&gt;
#heading { color: sandybrown; text-decoration: line-through; }
&lt;/style&gt;
&lt;h2 id="heading">이 부분에 스타일을 적용합니다.&lt;/h2>


        </code></pre>
    </div>
    <p>HTML과 CSS에서는 하나의 웹 페이지에 속하는 여러 요소에 같은 아이디 이름을 사용해도 별 문제없이 동작합니다.

        하지만 이렇게 중복된 아이디를 가지고 자바스크립트 작업을 하게 되면 오류가 발생합니다.

        따라서 되도록이면 하나의 웹 페이지에 속하는 요소에는 다른 아이디 이름을 사용하거나 클래스를 사용하는 것이 좋습니다.

    </p>


    <h3>클래스(class) 선택자</h3>
    <p>클래스 선택자는 특정 집단의 여러 요소를 한 번에 선택할 때 사용합니다.

        이러한 특정 집단을 클래스(class)라고 하며, 같은 클래스 이름을 가지는 요소들을 모두 선택해 줍니다.</p>
    <div class="code">
        <pre><code>
&lt;style&gt;
.headings { color: deepskyblue; text-decoration: overline; }
&lt;/style&gt;
&lt;h2 class="headings"&gt;이 부분에 스타일을 적용합니다.&lt;/h2&gt;

&lt;p&gt;클래스 선택자를 이용하여 스타일을 적용할 HTML 요소들을 한 번에 선택할 수 있습니다.&lt;/p&gt;

&lt;h3 class="headings"&gt;이 부분에도 같은 스타일을 적용합니다.&lt;/h3&gt;


        </code></pre>
    </div>


    <h3>그룹 선택자</h3>
    <p>그룹 선택자는 위에서 언급한 여러 선택자를 같이 사용하고자 할 때 사용합니다.

        그룹 선택자는 여러 선택자를 쉼표(,)로 구분하여 연결합니다.

        이러한 그룹 선택자는 코드를 중복해서 작성하지 않도록 하여 코드를 간결하게 만들어 줍니다.

    </p>
    <div class="code">
        <pre><code>
&lt;style&gt;
h2 { color: navy; }

    h2, h3 { text-align: center; }

    h2, h3, p { background-color: lightgray; }
&lt;/style&gt;

</code></pre>
    </div>






    <div class="iframe">
        <iframe src="https://namhajun.github.io/webs_class/javascript/effect/searchEffect04.html"></iframe>
    </div>
    <pre class="typescript"><code>
const searchBox = document.querySelector("#search-box");  
const cssCount = document.querySelector(".count");
const cssDesc = document.querySelector(".desc");
const cssList = document.querySelector(".list");

//CSS 속성 값/전체 갯수 출력하기
cssProperty.map((element, index) => {
    cssCount.innerText = "전체 목록 갯수 : "+ (index+1) +"개";  
    cssList.innerHTML += "<span>"+ element.name +"</span>";
});
//사용자가 검색한 값
searchBox.addEventListener("keyup", () => {
    const searchWord = searchBox.value;
    //console.log(searchWord)
    findProp(searchWord);
});

document.querySelectorAll(".list span").forEach(span =>{
    span.addEventListener("click", () => {
        //클릭한 데이터 값을 가져오기
        const listProp = span.innerText;
        findProp(listProp);
    })
})
function findProp(searchProp){
    const targetData = cssProperty.find((data) => data.name === searchProp)

    //찾는 데이터가 없을때
    
    if(targetData == null){
        cssDesc.textContent = "해당 속성은 존재하지 않습니다. 다시 검색해 주세요!";
        return;
    }

        cssDesc.innerHTML = targetData.desc;
}
</code></pre>

    <a href="https://namhajun.github.io/webs_class/javascript/javascript06.html#sample10">find()</a>
















    //버튼을 클릭했을때
    searchBox.forEach(el => {
    el.addEventListener("click", (event) => {
    oneClickButton(event)
    });
    });

    //변수,(데이터 저장+변경+추가+전역/지역),
    // 배열(순차적으로 여러개 데이터저장),
    // 객체,
    // 함수(실행문 집합체, 재활용)
    function oneClickButton(event){
    //클릭한 대상의 view값을 값을 가져와야 경고창으로 보여주세요
    const button = event.taget; //사용자가 클릭한 버튼 타겟 설정
    const targetView = button.dataset.view;
    const filerList= cssProperty.filter((data)=> data.view >= targetView);
    upDataList(filerList);

    }

    //css 리스트 출력하기
    function upDataList(filerList){
    let list = "";

    for(let data of filerList){
    // list += "<li>"+cssProperty[i].view+"</li>"
    list += '<li>${data.name} :${data.desc}<span>${datav.iew}</span></li>';
    }


    cssList.innerHTML = list;

    }
    upDataList();




    <h3>transition </h3>
    <p>1. 해당 요소에 추가할 CSS 스타일 전환(transition) 효과를 설정합니다.<br>

        2. 추가할 전환 효과가 지속될 시간을 설정합니다.</p>

    <h3>transition-timing-function 속성</h3>
    <p>transition-timing-function 속성은 전환(transition) 효과의 시간당 속도를 설정합니다.



        transition-timing-function 속성의 속성값으로는 다음과 같은 값을 설정할 수 있습니다.</p>

    <ul>
        <li>1. linear : 전환(transition) 효과가 처음부터 끝까지 일정한 속도로 진행됩니다.</li>

        <li> 2. ease : 기본값으로, 전환(transition) 효과가 천천히 시작되어, 그다음에는 빨라지고, 마지막에는 다시 느려집니다.</li>

        <li> 3. ease-in : 전환(transition) 효과가 천천히 시작됩니다.</li>

        <li> 4. ease-out : 전환(transition) 효과가 천천히 끝납니다.</li>

        <li>5. ease-in-out : 전환(transition) 효과가 천천히 시작되어, 천천히 끝납니다.</li>

        <li> 6. cubic-bezier(n,n,n,n) : 전환(transition) 효과가 사용자가 정의한 cubic-bezier 함수에 따라 진행됩니다.</li>


    </ul>

    <div class="code">
        <pre><code>
&lt;style&gt;

    div {

        width: 100px;

        -webkit-transition: width 1s;

        transition: width 1s;

    }

    #div_01 {

        -webkit-transition-timing-function: linear;

        transition-timing-function: linear;

    }

    #div_05 {

        -webkit-transition-timing-function: ease-in-out;

        transition-timing-function: ease-in-out;

    }

    div:hover { width: 300px; }

&lt;/style&gt;
            </code></pre>
    </div>


    <h3>transition-delay</h3>
    <p>transition-delay 속성은 전환(transition) 효과가 나타나기 전까지의 지연 시간을 설정합니다.

        전환(transition) 효과는 이 메소드로 설정된 시간이 흐른 뒤에야 비로소 시작됩니다.</p>


    <div class="code">
        <pre><code>
&lt;style&gt;
#resize {

    height: 100px;

    width: 150px;

    -webkit-transition: width 1s, height 2s;

    transition: width 1s, height 2s;

    -webkit-transition-delay: 1s;

    transition-delay: 1s;

}

#resize:hover { width: 300px; height: 300px; }
&lt;/style&gt;
            </code></pre>
    </div>

    <h3>전환(transition) 효과와 변형(transform) 효과의 동시 적용</h3>
    <p>전환(transition) 효과와 변형(transform) 효과를 같이 적용할 수도 있습니다.</p>

    <div class="code">
        <pre><code>
&lt;style&gt;
#windmill {

    height: 100px;

    width: 100px;

    -webkit-transition: width 2s, height 2s, -webkit-transform 2s;

    transition: width 2s, height 2s, transform 2s;

}

#windmill:hover {

    width: 300px;

    height: 300px;

    -webkit-transform: rotateY(180deg);

    transform: rotateY(180deg);

}
&lt;/style&gt;
        </code></pre>
    </div>
    <h4>CSS3 transition 속성</h4>

    <table>
        <thead>
            <tr>
                <th>속성</th>
                <th>설명</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>transition</td>
                <td>모든 transition 속성을 이용한 스타일을 한 줄에 설정할 수 있음.</td>
            </tr>
            <tr>
                <td>transition-property</td>
                <td>요소에 추가할 전환(transition)&nbsp;효과를 설정함.</td>
            </tr>
            <tr>
                <td>transition-duration</td>
                <td>전환(transition)&nbsp;효과가 지속될 시간을 설정함.</td>
            </tr>
            <tr>
                <td>transition-timing-function</td>
                <td>전환(transition) 효과의 시간당 속도를 설정함.</td>
            </tr>
            <tr>
                <td>transition-delay</td>
                <td>전환(transition) 효과가 나타나기 전까지의&nbsp;지연 시간을 설정함.</td>
            </tr>
        </tbody>
    </table>


    <h3>@규칙(at-rule)</h3>
    <p>CSS에서는 W3C에서 규정하고 있는 몇몇 규칙들을 사용할 수 있습니다.</p>
    <ul>
        <li>1. @import </li>

        <li>2. @font-face </li>

        <li>3. @media </li>


    </ul>

    <h3>@import 규칙</h3>
    <p>@import 규칙은 다른 스타일 시트에서 스타일 규칙을 가져올 수 있는 규칙입니다.

        이 규칙은 스타일 시트에 사용되는 문자 인코딩을 지정하는 @charset 규칙을 제외하고 모든 다른 규칙보다 앞서 명시되어야 합니다.</p>
    <p>보통 HTML 문서에는 다음과 같이 여러 개의 &lt;link&gt;태그를 사용하여 스타일 시트를 추가합니다.</p>
    <div class="code">
        <pre><code>
&lt;head&gt;
&lt;title&gt;@import 규칙&lt;/title&gt;

&lt;link rel="stylesheet" href="firstStyleSheet.css"&gt;

&lt;link rel="stylesheet" href="secondStyleSheet.css"&gt;

...

&lt;link rel="stylesheet" href="hundredStyleSheet.css"&gt;
&lt;/head&gt;
        </code></pre>
    </div>

    <p>하지만 이렇게 추가하는 CSS 파일의 개수가 늘어날수록 웹 서버의 부하도 같이 커지게 됩니다.

        따라서 HTML 문서에는 일정 개수의 CSS 파일만을 추가하고, 추가된 CSS 파일에서 @import 규칙을 이용해 또 다른 CSS 파일을 추가하는 방법을 사용합니다.

    </p>

    <div class="code">
        <h3>HTML 문서</h3>
        <pre><code>
    &lt;head&gt;
    &lt;title&gt;@import 규칙&lt;/title&gt;

    
    &lt;link rel="stylesheet" href="firstStyleSheet.css"&gt;
    
    &lt;link rel="stylesheet" href="secondStyleSheet.css"&gt;

    &lt;/head&gt;
            </code></pre>
    </div>

    <p>@import 규칙을 사용해도 추가하는 CSS 파일의 개수가 늘어나면 여전히 웹 서버의 부하는 커질 수밖에 없습니다.

        따라서 웹 서버의 부하를 줄이기 위해 작성한 CSS 파일들을 적절히 분산해서 추가하는 방법이 필요해집니다.



        @import 규칙을 이용하면 미디어 쿼리(media query)의 조건에 따라 필요한 CSS 파일만을 선별적으로 불러올 수 있습니다.</p>




<h3>@font-face 규칙</h3>

<p>@font-face 규칙은 웹 폰트(web font)를 정의할 때 사용하는 규칙입니다.

    웹 폰트(web font)는 사용자의 컴퓨터에 설치되어 있지 않은 글꼴(font)을 웹 브라우저가 사용할 수 있게 해줍니다.
    
     
    
    우선 웹 폰트를 서버에 올려놓고, CSS 파일에 @font-face 규칙을 사용하여 웹 폰트를 정의하고 추가합니다.
    
    그러면 해당 웹 페이지에 접속하는 모든 웹 브라우저는 자동으로 서버에서 웹 폰트를 내려받아 해당 글꼴을 표시하게 됩니다.</p>


<div class="code">
        <pre><code>
&lt;style&gt;
@font-face {

    font-family: "myWebFont";

    src: local("NanumGothic"), url("NanumGothic.eot"), url("NanumGothic.ttf"), url("NanumGothic.woff");

}

* { font-family: "myWebFont"; }
&lt;/style&gt;
        </code></pre>
    </div>


<h3>@media 규칙</h3>
<p>CSS2에서는 @media 규칙을 통해 서로 다른 미디어 타입(media type)을 위한 맞춤식 스타일 시트를 지원합니다.

 

    다음 예제는 HTML 문서가 스크린에 표현될 때와 프린트할 때 서로 다른 스타일을 적용해 주는 예제입니다.</p>



    <div class="code">
        <pre><code>
&lt;style&gt;
body { background-color: darkorange; }

@media screen {

    body { background-color: black; color: white; }

}

@media print {

    body { background-color: white; color: black; }

}
&lt;/style&gt;
        </code></pre>
    </div>



<h3>동위 선택자(sibling selector)</h3>
<p>동위 선택자는 동위 관계에 있는 요소 중에서 해당 요소보다 뒤에 존재하는 특정 타입의 요소를 모두 선택합니다.

 

    동위 관계란 HTML 요소의 계층 구조에서 같은 부모(parent) 요소를 가지고 있는 요소들을 의미합니다.
    
    이러한 동위 관계에 있는 요소들을 형제(sibling) 요소라고 합니다.
    
     </p>
     <div class="code">
        <pre><code>
&lt;style&gt;
body { background-color: darkorange; }

@media screen {

    body { background-color: black; color: white; }

}

@media print {

    body { background-color: white; color: black; }

}
&lt;/style&gt;
        </code></pre>
    </div>
<p>위의 그림에서 초록색으로 표시된 세 요소는 모두 &lt;body&gt;요소를 부모 요소로 가집니다.

    따라서 이 세 요소는 동위 관계에 있는 형제 요소라고 할 수 있습니다.</p>

<h3>일반 동위 선택자(general sibling selector)</h3>
<p>일반 동위 선택자는 해당 요소와 동위 관계에 있으며, 해당 요소보다 뒤에 존재하는 특정 타입의 요소를 모두 선택합니다.

 

<h3>인접 동위 선택자(adjacent sibling selector)</h3>
<p>영어로 adjacent는 인접한, 가까운 이라는 의미가 있습니다.
    인접 동위 선택자는 해당 요소와 동위 관계에 있으며, 해당 요소의 바로 뒤에 존재하는 특정 타입의 요소를 모두 선택합니다..</p>
    
     
    <h3>navigation bar</h3>
    <p>사용자가 웹 사이트에서 가장 많이 클릭하는 영역 중 하나가 바로 내비게이션 바입니다.

        내비게이션 바(navigation bar)는 우리가 흔히 사용하는 웹 사이트의 메뉴를 의미합니다.
        
        HTML 요소만으로 만든 단순한 메뉴에 CSS를 이용하면, 보기에도 이쁘고 쓰기도 편리한 메뉴로 손쉽게 바꿀 수 있습니다.</p>



        <h3>링크를 사용한 리스트 메뉴</h3>
        <p>내비게이션 바 중에서도 가장 기본적인 것이 바로 링크(link)를 사용한 리스트 메뉴입니다.

            HTML에서 링크는 <a>태그로 표현합니다.</p>


    <div class="code">
        <pre><code>
            &lt;ul&gt;

                &lt;li&gt;&lt;a href="/index.php"&gt;Home&lt;/a&gt;&lt;/li&gt;
            
                &lt;li&gt;&lt;a href="/html/intro"&gt;HTML&lt;/a&gt;&lt;/li&gt;
            
                &lt;li&gt;&lt;a href="/css/intro"&gt;CSS&lt;/a&gt;&lt;/li&gt;
            
                &lt;li&gt;&lt;a href="/javascript/intro"&gt;자바스크립트&lt;/a&gt;&lt;/li&gt;
            
            &lt;/ul&gt;
            
            
        </code></pre>
    </div>

    <h3>수직 내비게이션 바</h3>
    <p>링크를 사용한 리스트 메뉴에 display 속성값을 block으로 설정하면, 간단히 수직 내비게이션 바를 만들 수 있습니다.</p>

    <div class="code">
        <pre><code>
           &lt;style&gt;

                ul { background-color: #FFDAB9; width: 150px; list-style-type: none; margin: 0; padding: 0; }
            
                li a { display: block; color: #000000; padding: 8px; text-decoration: none; font-weight: bold; }
            
                li a:hover { background-color: #CD853F; color: white; }
            
           &lt;/style&gt;
            
        </code></pre>
    </div>
<p>위의 예제에서 인라인 요소인 &lt;a&gt;요소의 display 속성값을 블록(block)으로 변경하면, 메뉴의 어느 곳을 클릭하더라도 바로 연결된 페이지로 넘어가게 설정됩니다.</p>

<p>클래스(class)를 이용하면 내비게이션 바에서 현재 메뉴의 위치도 표현할 수 있습니다.</p>
<div class="code">
    <pre><code>
       &lt;style&gt;
        li a.current { background-color: #FF6347; color: white; }
    
        li a:hover:not(.current) { background-color: #CD853F; color: white; }

       &lt;/style&gt;
        
    </code></pre>
</div>

<h3>수평 내비게이션 바</h3>
<p>수평 내비게이션 바는 다음과 같은 속성을 이용해 만들 수 있습니다.</p>
<ul>
<li>1. display 속성의 inline 속성값을 이용한 방법</li>
<li>2. floating 속성을 이용한 방법</li>
</ul>

<h3>display 속성의 inline 속성값을 이용한 방법</h3>
<p>링크를 사용한 리스트 메뉴에서 &lt;li&gt;요소의 display 속성값을 inline으로 설정합니다.

    그러면 블록 요소였던 &lt;li&gt;요소가 인라인 요소의 성질을 갖도록 변경됩니다.
    
     
    
    인라인 요소로 변경된 &lt;li&gt;요소는 너비가 자신의 내용만큼만을 차지하도록 변경됩니다.
    
    따라서 모든 &lt;li&gt;요소가 수평으로 늘어서게 되며, 이것을 이용하여 수평 내비게이션 바를 만들게 됩니다.</p>
    <div class="code">
        <pre><code>
           &lt;style&gt;
           li { float: left; }

           li a { display: block; background-color: #FFDAB9; padding: 8px; }
           &lt;/style&gt;
            
        </code></pre>
    </div>
<p>CSS를 이용하면 수평 내비게이션 바에 여러 가지 스타일을 설정할 수 있습니다.</p>
<div class="code">
    <pre><code>
       &lt;style&gt;
       ul { background-color: #FFDAB9; list-style-type: none; margin: 0; padding: 0; overflow: hidden; }

       li { float: left; }
   
       li a { display: block; background-color: #FFDAB9; color: #000000; padding: 8px; text-decoration: none;
   
           text-align: center; font-weight: bold; }
   
       li a:hover { background-color: #CD853F; color: white; }
       &lt;/style&gt;
        
    </code></pre>
</div>
<p>클래스(class)를 이용하면 내비게이션 바에서 현재 메뉴의 위치도 표현할 수 있습니다.</p>
<div class="code">
    <pre><code>
       &lt;style&gt;
       li a.current { background-color: #FF6347; color: white; }

    li a:hover:not(.current) { background-color: #CD853F; color: white; }
       &lt;/style&gt;
        
    </code></pre>

<h3>Number 객체</h3>
<p>자바스크립트에서는 정수와 실수를 따로 구분하지 않고, 모든 수를 실수 하나로만 표현합니다.

    자바스크립트에서 모든 숫자는 IEEE 754 국제 표준에서 정의한 64비트 부동 소수점 수로 저장됩니다.
    
     </p>

<p>64비트 부동 소수점 수(double precision floating point numbers)는 메모리에 다음과 같은 형태로 저장됩니다.</p>
<table>
	<thead>
		<tr>
			<th>0 ~ 51 비트</th>
			<th>52 ~ 62 비트</th>
			<th>63 비트</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>총 52비트의 가수 부분</td>
			<td >총 11비트의 지수 부분</td>
			<td >총 1비트의 부호 부분</td>
		</tr>
	</tbody>
</table>

<p>이러한 64비트 부동 소수점 수의 정밀도는 정수부는 15자리까지, 소수부는 17자리까지만 유효합니다.</p>

<h3>진법 표현</h3>
<p>자바스크립트에서는 기본적으로 10진법을 사용하여 수를 표현합니다.

    하지만 0x 접두사를 사용하여 16진법으로 수를 표현할 수도 있습니다.</p>

    <div class="code">
        <pre><code>
            var x = 0xAB; // 16진법으로 표현된 10진수 171

            var y = 29;   // 10진법으로 표현된 10진수 29
            
            x + y;        // 두 수 모두 10진법으로 자동으로 변환되어 계산됨. -> 200
            
        </code></pre>
    <p>또한, 숫자에 toString() 메소드를 사용하여 해당 숫자를 여러 진법의 형태로 변환할 수 있습니다.</p>
    <div class="code">
        <pre><code>
            var num = 256;

            num.toString(2);       //  2진법으로 변환 : 100000000
            
            num.toString(8);       //  8진법으로 변환 : 400
            
            num.toString(10);      // 10진법으로 변환 : 256
            
            num.toString(16);      // 16진법으로 변환 : 100
            
            // 2진수로 변환한 결괏값을 문자열로 반환함.
            
            num.toString(2);       // 100000000
            
            // 문자열을 숫자로 나눴기 때문에 자동으로 10진수로 변환되어 산술 연산된 결괏값
            
            (num.toString(2) / 2); // 50000000
        </code></pre>

<h3>Infinity</h3>
<p>자바스크립트에서는 양의 무한대를 의미하는 Infinity 값과 음의 무한대를 의미하는 -Infinity 값을 사용할 수 있습니다.

    Infinity 값은 사용자가 임의로 수정할 수 없는 읽기 전용 값이며, 자바스크립트의 어떤 수보다도 큰 수로 취급됩니다.</p>


    <div class="code">
        <pre><code>
            var x = 10 / 0;         // 숫자를 0으로 나누면 Infinity를 반환함.

            var y = Infinity * 1000 // Infinity에 어떠한 수를 산술 연산해도 Infinity를 반환함.
            
            var z = 1 / Infinity    // Infinity의 역수는 0을 반환함.
            
            x;                      // Infinity
            
            y;                      // Infinity
            
            z;                      // 0
            
            
        </code></pre>

<h3>NaN</h3>
<p>NaN(Not A Number)는 숫자가 아니라는 의미로, 정의되지 않은 값이나 표현할 수 없는 값을 가리킵니다.

    0을 0으로 나누거나, 숫자로 변환할 수 없는 피연산자로 산술 연산을 시도하는 경우에 반환되는 읽기 전용 값입니다.</p>

    <div class="code">
        <pre><code>
            var x = 100 - "10";     // "10"은 자동으로 숫자로 변환되어 계산됨.

            var y = 100 - "문자열"; // "문자열"은 숫자로 변환할 수 없기 때문에 NaN을 반환함.
            
            var z = 0 / 0;          // 0을 0으로 나눌 수 없기 때문에 NaN을 반환함.
            
            x;                      // 90
            
            y;                      // NaN
            
            z;                      // NaN
        </code></pre>
<p>자바스크립트의 전역 함수 중 하나인 isNaN() 함수를 사용하면, 전달받은 값이 숫자인지 아닌지를 판단해 줍니다.</p>

<div class="code">
        <pre><code>
            var x = 100 * "문자열";

            if(isNaN(x)) { // 전달된 값이 숫자인지 아닌지를 검사함.
            
                document.write("변수 x의 값은 숫자가 아닙니다.");
            
            } else {
            
                document.write("변수 x의 값은 숫자입니다.");
            
            }            
        </code></pre>
<h3>null, undefined, NaN, Infinity에 대한 비교</h3>

<p>자바스크립트에서는 약간은 비슷한 것 같으면서도 전혀 다른 4가지 값을 제공하고 있습니다.</p>
<ul>
    <li>- null은 object 타입이며, 아직 '값'이 정해지지 않은 것을 의미하는 값입니다.</li>

        <li>  - undefined는 null과는 달리 하나의 타입이며, '타입'이 정해지지 않은 것을 의미하는 값이기도 합니다.</li>
        
            <li>  - NaN은 number 타입이며, '숫자가 아님'을 의미하는 숫자입니다.</li>
        
                <li> - Infinity는 number 타입이며, '무한대'를 의미하는 숫자입니다.</li>
</ul>
<p>자바스크립트는 타입 검사가 매우 유연한 언어입니다.

    따라서 위의 값들 또한 문맥에 따라 다음과 같이 자동으로 타입 변환이 이루어집니다.</p>


    <table >
        <thead>
            <tr>
                <th style="width: 25%;">값</th>
                <th style="width: 25%;">Boolean 문맥</th>
                <th style="width: 25%;">Number 문맥</th>
                <th style="width: 25%;">String 문맥</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>null</td>
                <td>false</td>
                <td>0</td>
                <td>&quot;null&quot;</td>
            </tr>
            <tr>
                <td>undefined</td>
                <td>false</td>
                <td>NaN</td>
                <td>&quot;undefined&quot;</td>
            </tr>
            <tr>
                <td>NaN</td>
                <td>false</td>
                <td>NaN</td>
                <td>&quot;NaN&quot;</td>
            </tr>
            <tr>
                <td>Infinity</td>
                <td>true</td>
                <td>Infinity</td>
                <td>&quot;Infinity&quot;</td>
            </tr>
        </tbody>
    </table>

<h3>Number 객체</h3>
<p>자바스크립트에서 숫자는 보통 숫자 리터럴을 사용하여 표현합니다.

 

    하지만 수를 나타낼 때 new 연산자를 사용하여 명시적으로 Number 객체를 생성할 수도 있습니다.
    
    이러한 Number 객체는 숫자 값을 감싸고 있는 래퍼(wrapper) 객체입니다</p>
    <div class="code">
        <pre><code>
            var x = 100;             // 숫자 리터럴

            var y = new Number(100); // Number 객체
            
            x;                       // 100
            
            y;                       // 100
            
            typeof x;                // number 타입
            
            typeof y;                // object 타입
        </code></pre>
<p>동등 연산자(==)는 리터럴 값과 객체의 값이 같으면 true를 반환합니다.

    하지만 일치 연산자(===)는 숫자 리터럴과 Number 객체의 타입이 다르므로, 언제나 false를 반환합니다.</p>
    <div class="code">
        <pre><code>
            var x = 100;             // 숫자 리터럴 100

            var y = new Number(100); // Number 객체 100
            
            x == y;                  // 값이 같으므로 true
            
            x === y;                 // 서로 다른 객체이므로 false
        </code></pre>

<h3>드롭다운(dropdown) 효과</h3>
<p>해당 요소에 마우스를 올려서 다른 요소나 텍스트가 나타나게 하는 효과를 드롭다운(dropdown) 효과라고 합니다.

    CSS를 이용하면 이러한 드롭다운 효과를 간단히 설정할 수 있습니다.</p>


<p>다음 예제는 display 속성을 이용하여 드롭다운 효과를 구현하는 예제입니다.</p>


<div class="code">
    <pre><code>
       &lt;style&gt;
       .dropdown { position: relative; display: inline-block; }

       .dropdown-content {
   
           display: none;
   
           position: absolute;
   
           background-color: #F9F9F9;
   
           min-width: 160px;
   
           padding: 8px;
   
           box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
   
       }
   
       .dropdown:hover .dropdown-content { display: block; }
       &lt;/style&gt;
        
    </code></pre>
<p> 

    위의 예제에서 사용자가 마우스를 올리면 나타날 &lt;div&gt;요소의 display 속성값을 none으로 설정합니다.
    
    이렇게 설정하면 처음에는 눈에 보이지 않게 됩니다.
    
     
    
    하지만 특정 요소에 마우스를 올리면 해당 &lt;div&gt;요소의 display 속성값이 블록(block)으로 변경됩니다.
    
    따라서 이때에는 이 &lt;div&gt;요소가 눈에 보이게 됩니다.
    
    </p>
<h3>드롭다운(Dropdown) 메뉴</h3>
<p>메뉴에 마우스를 올리면 하위 메뉴가 나타나게 하는 메뉴를 드롭다운(dropdown) 메뉴라고 합니다.

    드롭다운 효과를 이용하면 이러한 드롭다운 메뉴도 간단히 구현할 수 있습니다.</p>
    <div class="code">
        <pre><code>
           &lt;style&gt;
           .dropdown-button { background-color: #FFDAB9; padding: 8px; font-size: 15px; border: none; }

           .dropdown { position: relative; display: inline-block; }
       
           .dropdown-content {
       
               display: none;
       
               position: absolute;
       
               background-color: #FFDAB9;
       
               min-width: 70px;
       
               padding: 8px;
       
               box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
       
           }
       
           .dropdown-content a { color: black; padding: 8px; text-decoration: none; display: block; }
       
           .dropdown-content a:hover { background-color: #CD853F; }
       
           .dropdown:hover .dropdown-content { display: block; }
       
           .dropdown:hover .dropdown-button { background-color: #CD853F; }
           &lt;/style&gt;
            
        </code></pre>

<h3>툴팁(tooltip) 효과</h3>
<p>해당 요소에 마우스를 올리면 추가적인 정보가 나타나게 하는 효과를 툴팁(tooltip) 효과라고 합니다.

    CSS를 이용하면 이러한 툴팁 효과를 간단히 설정할 수 있습니다.
    </p>
    <div class="code">
        <pre><code>
           &lt;style&gt;
           .tooltip { position: relative; display: inline-block; }

    .tooltip .tooltip-content {

        visibility: hidden;

        width: 300px;

        background-color: orange;

        padding: 0;

        margin-top: 10px;

        color: white;

        text-align: center;

        position: absolute;

        z-index: 1;

    }

    .tooltip:hover .tooltip-content { visibility: visible; }
           &lt;/style&gt;
            
        </code></pre>


<p>CSS를 이용하면 툴팁(tooltip)이 나타나는 위치도 간단히 설정할 수 있습니다.

    CSS의 상대적 위치를 나타내는 top, right, bottom, left 속성을 이용하여 툴팁의 상대 위치를 설정할 수 있습니다.</p>


<p>CSS를 이용하면 툴팁(tooltip)이 나타나는 위치도 간단히 설정할 수 있습니다.

    CSS의 상대적 위치를 나타내는 top, right, bottom, left 속성을 이용하여 툴팁의 상대 위치를 설정할 수 있습니다.</p>


    <div class="code">
        <pre><code>
           &lt;style&gt;
           .tooltip { margin: auto; }

           .tooltip .tooltip-content { top: -15px; right: 105%; }
           &lt;/style&gt;
            
        </code></pre>

<p>다음 예제는 해당 요소에 마우스를 올리면 툴팁이 위쪽에 나타나도록 구현한 예제입니다.</p>


<div class="code">
    <pre><code>
       &lt;style&gt;
       .tooltip { margin: auto; }

       .tooltip .tooltip-content { bottom: 100%; left: 50%; margin-left: -150px; }
       &lt;/style&gt;
        
    </code></pre>

<p>또한, 다음 예제처럼 툴팁(tooltip)의 모양을 말풍선 모양처럼 설정할 수도 있습니다.</p>

<div class="code">
    <pre><code>
       &lt;style&gt;
       .tooltip .tooltip-content::after {

        content: " ";

        position: absolute;

        top: 100%;

        left: 50%;

        margin-left: -10px;

        border-width: 10px;

        border-style: solid;

        border-color: orange transparent transparent transparent;

    }
       &lt;/style&gt;
        
    </code></pre>




<h3>transform </h3>
<p>transform속성은 웹요소의 위치를 이동시키거나 크기 조절 및 회전시킬 수 있는 기능을 가지고 있습니다.</p>


<h3>transform 속성</h3>
<ul>
   <li>scale()</li> 
   <li> rotate()</li> 
   <li>  translate()</li> 
   <li> skew()</li> 
</ul>
    
<h3>transform:scale() - X 또는 Y축으로 확대/ 축소</h3>   
<p>scale은 해당 요소를 지정한 크기만큼 확대 또는 축소 시킬 수 있습니다.
    사용방법은 아래와 같습니다.</p>
    <div class="code">
        <pre><code>
            transform:scaleX(x축 비율);          // x축으로 확대, 축소
            transform:scaleY(y축 비율);          // y축으로 확대, 축소
            transform:scale(x축 비율, y축 비율);  // x축, y축으로 확대, 축소
        </code></pre>
    
        <h3>transform:rotate() - 지정 요소 회전</h3>
<p>rotate는 요소를 지정한 각도만큼 회전시킵니다.
    회전 각도가 플러스 값일 경우 시계 방향, 마이너스 값일 경우 반시계 방향으로 회전합니다.
    사용방법은 아래와 같습니다.</p>

 <div class="code">
        <pre><code>
            transform:rotateX(Ndeg);  // x축 기준으로 N도 만큼 회전
            transform:rotateY(Ndeg);  // y축 기준으로 N도 만큼 회전
            transform:rotate(Ndeg);   // N도 만큼 회전
        </code></pre>


        <h3>transform:translate() - 지정 요소 X 또는 Y축으로 이동</h3>
        <p>translate는 요소를 지정한 위치로 X 또는 Y축만큼 이동 시킵니다.
            사용방법은 아래와 같습니다.
            </p>
        
         <div class="code">
                <pre><code>
                    transform:translateX(10px);        // X축으로 10px 이동
                    transform:translateY(10px);        // Y축으로 10px 이동
                    transform:translate(-10px, -10px); // X축으로 -10px, Y축으로 -10px 이동
                    
                </code></pre>
        




                <h3>ransform:skew() - 지정 요소 X 또는 Y축으로 기울이기</h3>
                <p>transform-origin:x축 y축;  // px, 백분율(%), left, center, right 중에서 사용할 수 있습니다.
                    </p>
                
                 <div class="code">
                        <pre><code>
                            transform:skewX(Ndeg);             // x축으로 N도 만큼 기울이기
                            transform:skewY(Ndeg);             // y축으로 N도 만큼 기울이기
                            transform:skew(x축 Ndeg, y축 Ndeg); // x축, y축으로 N도 만큼 기울이기
                            
                        </code></pre>
                



                        <h3>transform-origin 속성</h3>
                        <p>위의 transform 속성인 scale(), rotate(), translate(), skew()들을 한번씩 연습해 보았다면, 지정 요소의 중심을 기준으로 동작한다는 것을 알 수 있을 것 입니다.
                            하지만 transform-origin 을 사용하면 지정 요소의 기준점을 변경할 수 있습니다.
                            사용방법은 아래와 같습니다</p>
                        
                         <div class="code">
                                <pre><code>
                                    transform-origin:x축 y축;  // px, 백분율(%), left, center, right 중에서 사용할 수 있습니다.
                                </code></pre>
                        

                                <h3>white-space</h3>
<p>white-space는 스페이스와 탭, 줄바꿈, 자동줄바꿈을 어떻게 처리할지 정하는 속성입니다.</p>


<h3>문법</h3>
<ul>
    <li>normal, nowrap, pre, pre-wrap, pre-line : 아래 표 참고</li>
<li>  initial : 기본값으로 설정합니다.</li>
<li>  inherit : 부모 요소의 속성값을 상속받습니다.</li>
</ul>
<table>
    <tbody>
    <tr>
    <td> </td>
    <td>스페이스와 탭<sup>1</sup></td>
    <td>줄바꿈<sup>2</sup></td>
    <td>자동 줄바꿈<sup>3</sup></td>
    </tr>
    <tr>
    <td>normal</td>
    <td>병합</td>
    <td>병합</td>
    <td>O</td>
    </tr>
    <tr>
    <td>nowrap</td>
    <td>병합</td>
    <td>병합</td>
    <td>X</td>
    </tr>
    <tr>
    <td>pre</td>
    <td>보존</td>
    <td>보존</td>
    <td>X</td>
    </tr>
    <tr>
    <td>pre-wrap</td>
    <td>보존</td>
    <td>보존</td>
    <td>O</td>
    </tr>
    <tr>
    <td>pre-line</td>
    <td>병합</td>
    <td>보존</td>
    <td>O</td>
    </tr>
    </tbody>
    </table>

<ul>
    <li>연속된 스페이스와 탭의 처리 방법입니다. 병합은 1개의 공백으로 바꾸는 것이고, 보존은 입력된 그대로 출력하는 것입니다.</li>
<li>  줄바꿈의 처리방법입니다. 병합은 1개의 공백으로 바꾸는 것이고, 보존은 입력된 그대로 출력하는 것입니다.</li>
<li> 내용이 영역의 크기를 벗어날 때 처리방법입니다. O는 자동으로 줄바꿈하여 영역 내에 내용을 표시하는 것이고, X는 영역을 벗어나더라도 입력된 대로 출력하는 것입니다.</li>
</ul>








</body>

</html>